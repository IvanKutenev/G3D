#include "/Engine/Public/Platform.ush"

int gWaterHeightTexSzX;
int gWaterHeightTexSzY;

float gTime;

Texture2D<float4> gWaterHeightPrevTexRO;
Texture2D<float4> gWaterVelocityTexRO;
RWTexture2D<float4> gWaterHeightTexRW;
 
static const float dt = 1.0f / 30.0f;
static const float dx = 1.0f;

[numthreads(8, 8, 1)]
void CalcHeightCS(int3 id : SV_DispatchThreadID)
{
    [branch]
    if (id.x == 0 || id.x >= gWaterHeightTexSzX - 1 || id.y == 0 || id.y >= gWaterHeightTexSzX - 1)
    {
        gWaterHeightTexRW[id.xy] = 0.05f + 0.01f * sin(2.0f * gTime);
        return;
    }

    float h_xp = gWaterVelocityTexRO[int2(id.x + 1, id.y)].x <= 0.0f ? gWaterHeightPrevTexRO[int2(id.x + 1, id.y)].x : gWaterHeightPrevTexRO[id.xy].x;
    float h_xm = gWaterVelocityTexRO[id.xy].x >= 0.0f ? gWaterHeightPrevTexRO[int2(id.x - 1, id.y)].x : gWaterHeightPrevTexRO[id.xy].x;
    
    float h_yp = gWaterVelocityTexRO[int2(id.x, id.y + 1)].y <= 0.0f ? gWaterHeightPrevTexRO[int2(id.x, id.y + 1)].x : gWaterHeightPrevTexRO[id.xy].x;
    float h_ym = gWaterVelocityTexRO[id.xy].y >= 0.0f ? gWaterHeightPrevTexRO[int2(id.x, id.y - 1)].x : gWaterHeightPrevTexRO[id.xy].x;

    float dhdt = -(
        h_xp * gWaterVelocityTexRO[int2(id.x + 1, id.y)].x - h_xm * gWaterVelocityTexRO[id.xy].x +
        h_yp * gWaterVelocityTexRO[int2(id.x, id.y + 1)].y - h_ym * gWaterVelocityTexRO[id.xy].y
    ) / dx;

    gWaterHeightTexRW[id.xy] = max(0.0f, gWaterHeightPrevTexRO[id.xy].x + dhdt * dt);
}