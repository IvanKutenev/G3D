#include "/Engine/Public/Platform.ush"

float gTime;

Texture2D<float2> gWaterVelocityTexRO;
Texture2D<float> gTerrainHeightTexRO;
Texture2D<float> gWaterHeightPrevTexRO;
RWTexture2D<float> gWaterHeightTexRW;

bool isInsideBounds(int3 id)
{
    return id.x > 0 && id.y > 0 && id.x < TEX_SZ - 1 && id.y < TEX_SZ - 1;
}

[numthreads(8, 8, 1)]
void CalcHeightCS(int3 id : SV_DispatchThreadID)
{
    [branch]
    if (!isInsideBounds(id))
    {
        gWaterHeightTexRW[id.xy] = gWaterHeightPrevTexRO[id.xy];
    }
    else
    {
        float h_xp = gWaterVelocityTexRO[int2(id.x + 1, id.y)].x <= 0.0f ?
            gWaterHeightPrevTexRO[int2(id.x + 1, id.y)] : gWaterHeightPrevTexRO[id.xy];
        float h_xm = gWaterVelocityTexRO[id.xy].x >= 0.0f ?
            gWaterHeightPrevTexRO[int2(id.x - 1, id.y)] : gWaterHeightPrevTexRO[id.xy];
    
        float h_yp = gWaterVelocityTexRO[int2(id.x, id.y + 1)].y <= 0.0f ?
            gWaterHeightPrevTexRO[int2(id.x, id.y + 1)] : gWaterHeightPrevTexRO[id.xy];
        float h_ym = gWaterVelocityTexRO[id.xy].y >= 0.0f ?
            gWaterHeightPrevTexRO[int2(id.x, id.y - 1)] : gWaterHeightPrevTexRO[id.xy];

        float dhdt = -(
            h_xp * gWaterVelocityTexRO[int2(id.x + 1, id.y)].x - h_xm * gWaterVelocityTexRO[id.xy].x +
            h_yp * gWaterVelocityTexRO[int2(id.x, id.y + 1)].y - h_ym * gWaterVelocityTexRO[id.xy].y
        ) / DELTA_X;

        gWaterHeightTexRW[id.xy] = max(0.0f, gWaterHeightPrevTexRO[id.xy] + dhdt * DELTA_TIME);
    }
}